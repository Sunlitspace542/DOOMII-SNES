{\rtf1\mac\deff2 {\fonttbl{\f0\fswiss Chicago;}{\f2\froman New York;}{\f3\fswiss Geneva;}{\f4\fmodern Monaco;}{\f13\fnil Zapf Dingbats;}{\f16\fnil Palatino;}{\f20\froman Times;}{\f21\fswiss Helvetica;}{\f22\fmodern Courier;}{\f23\ftech Symbol;}}{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\sbasedon222\snext0 Normal;}}{\info{\title Fred Guide}}\widowctrl\ftnbj\fracwidth \sectd \linemod0\cols1 \pard\plain {\fs20 \par \par }\pard \qc {\fs20 The twenty FIVE minute guide to Fred.\par with the extra five minutes spent updating for SNES\par 1/29/95\par }\pard {\fs20 \par \par }\pard {\fs20 In this document card will be used to refer to the Catapult design game modem.  Cartridge will refer to the game cartridge. Sega will be used to refer to the Sega Genesis box. \par }\pard {\fs20 \par Theory of operation\par }\pard {\fs20 Fred provides a mechanism to dynamically patch ROM code stored in a game cartridge. It is specifically focused at allowing synchronization of one game with another, but the means are fairly generic. Three mechanisms are used to allow code patching.  First, Fred can control the exception vectors for the processor.  All exception processing must pass through the card, allowing it to be modified if necessary.  Second, Fred can selectively replace arbitrary words with values stored in card RAM.  Inserting op-codes that generate exceptions allows the card to assume control at arbitrary locations, taking advantage of the previous mechanism of  controlling exception processing.  Finally, Fred can replace large linear address spaces with a same size range fetched from card RAM or ROM.  This function allows replacement of sound or graphic objects for a game.\par }\pard {\fs20 \par }\pard {\fs20 In practice, patching a cartridge ROM is somewhat trickier then it at first appears.  Sound and Graphic DMA occurs simultaneously with the main CPU access to the cartridge.  The DMA must be unaffected while the CPU code path is modified. A region of address space must be allocated to the card functions.  Since the card and the cartridge share the same 32 megabit address space on the Sega, this must be specific for each game.  Mortal Kombat is a 16 megabit cartridge, so all card resources can be placed in the second half of the address space.  Super Street Fighter II-Tournament Addition is a 40 megabit cartridge, so all card resources must be carefully placed in areas that are not used for DMA. Because of this all resource in Fred reside at programmable locations.\par }\pard {\fs20 \par }\pard {\fs20 In addition to the address remapping functions of Fred, it also provides a low latency serial port optimized for interface to a Rockwell modem.  This same serial port can be used to interface to ISO compliant serial smart cards.  Synchronous smart cards are also supported.  Finally Fred can directly drive 7 LEDs.\par }\pard {\fs20 \par }\pard {\fs20 The card has an operating system on it that provides a GUI for access to the X-Band functionality.  Fred defaults to a simple, flat address space to simplify OS development. \par }\pard {\fs20 \par Address spaces\par \par }\pard {\fs20 There are two fundamental address maps for Fred.  The first allows only visibility of the card resources.  This mode is termed "here" mode.  The second mode is intended for game patches.  In this mode, by default only the cartridge is visible, but various areas of card memory can be mapped into the cartridge address map.  In the second, the entire cartridge is visible, but some Fred resources can be enabled based on certain conditions.  A switch on the side of the device define which mode Fred defaults to on power up.  If down, it is "here" and the card is in control.  If up, then the cartridge is mapped in unchanged.  This effectively provides an on/off functionality for the card.\par }\pard {\fs20 \par "Here default" SEGA address map (reset map)\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x000000-0x000100\cell }\pard \intbl {\fs20 ROM\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x000100-0x000200\cell }\pard \intbl {\fs20 Cartridge at same address\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x000200-0x200000\cell }\pard \intbl {\fs20 ROM (aliased at 512k bytes boundary)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x200000-0x3bc000\cell }\pard \intbl {\fs20 RAM (aliased at 64k byte boundary)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x3bc000-0x3c0000\cell }\pard \intbl {\fs20 Registers (Here map)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x3c0000-0x400000\cell }\pard \intbl {\fs20 RAM (continued)\cell }\pard \intbl {\fs20 \row }\pard {\fs20 Note, that the hole at 0x100-0x200 does not exist when RAM is low, but due to a bug, that area is invalid (you are reading both the RAM and the Cartridge... ) for Sega 1.0 devices.\par }\pard {\fs20 \par "Here default" SNES address map (reset map)\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x000000-0x1FFFFF\cell }\pard \intbl {\fs20 ROM (high half, aliased at 1M)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x200000-0x3FFFFF\cell RAM (high half, aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x400000-0x1FFFFF\cell ROM (high half, aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x600000-0x3FFFFF\cell RAM (high half, aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x800000-0x9FFFFF\cell ROM (aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xA00000-0xBFFFFF\cell RAM (aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xC00000-0xDFFFFF\cell ROM (aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xE00000-0xFBBFFF\cell RAM (aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xFBC000-0xFBCFFF\cell Registers (Here Map)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0xFBD000-0xFFFFFF\cell RAM (aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The SNES address map is very simple, ROM and RAM are selected between by bit 21.  Of course, whereever the SNES maps in its resources, those will appear instead of the ROM of RAM values.\par \par These address maps can be affected by certain bits.  The RomHi bit in the Control register swaps RAM and ROM.  \par \par \par RomHi asserted, SEGA here mode\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x000000-0x200000\cell RAM (aliased at 64k bytes boundary)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x200000-0x3bc000\cell ROM (aliased at 512k byte boundary)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x3bc000-0x3bd000\cell Registers (Here map)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x3bd000-0x400000\cell ROM (continued)\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par RomHi asserted, SNES here mode\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x000000-0x1FFFFF\cell RAM (high half, aliased at 32k)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x200000-0x3FFFFF\cell ROM (high half, aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x400000-0x1FFFFF\cell RAM (high half, aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x600000-0x3FFFFF\cell ROM (high half, aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x800000-0x9FFFFF\cell RAM (aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xA00000-0xBFFFFF\cell ROM (aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xC00000-0xDFFFFF\cell RAM (aliased at 32k)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xE00000-0xFBBFFF\cell ROM (aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xFBC000-0xFBCFFF\cell Registers (Here Map)\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0xFBD000-0xFFFFFF\cell ROM (aliased at 1M)\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The EnTwoRAM for the SNES maps in the upper bank of SRAM.  This changes all of the above "aliased that 32k" to "aliased at 64k."\par \par Here Register map\par \par When here is asserted, the register area is mapped in.  Registers appear on the low order byte-lane on SEGA, thus can be read and written byte wise at odd addresses.  On SNES the registers appear on BOTH byte lanes.  Beware, a sixteen bit read will read a register twice, which will really screw up the modem recieve buffer.  The registers can be read or written on either byte lane.\par \par The general registers map alias from beginning of the register space through the end (address 3bc000-3bfe00 on SEGA, fbc000-fbfe00 on SNES).  The last chunk contains the two control registers.  For the sake of document simplicity, the address of each register is specified as an 8 bit value, which represents bits [9:1] of the access address.  This stays consistent across all the different location where the register can be accessed.  REMEMBER, MULTIPLY BY 2 TO GET THE REAL OFFSET.\par \par The register are grouped into two categories, general and control.  The control registers are responsible for most of the address mapping that goes on in the card. These two control registers (at 3bfe00) appear only during "here" mode due to a bug on SEGA 1.0 .  During soft here mode they can be found at address 0x180 word address on SEGA, 0x4f00 byte address on SNES plus their register offset, whether enFixedInternals is asserted or not.\par \par General registers map\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 address (bits 9:1 of address)\cell name\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x00\cell Translation address0[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x01\cell Translation address0[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x02\cell Translation address0[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x04\cell Translation address1[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x05\cell Translation address1[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x06\cell Translation address1[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 .\par . translation register 2-9 are here\par .\cell .\par .\par .\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x28\cell Translation address10[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x29\cell Translation address10[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x2a\cell Translation address10[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x2c\cell Range 0 Start[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x2d\cell Range 0 Start[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x2e\cell Range 0 Start[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x30\cell Range 1 Start[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x31\cell Range 1 Start[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x32\cell Range 1 Start[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x38\cell magic address[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x39\cell magic address[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x3a\cell magic address[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x40\cell Range 0 End[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x41\cell Range 0 End[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x42\cell Range 0 End[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x44\cell Range 1 End[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x45\cell Range 1 End[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x46\cell Range 1 End[22:16]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x50\cell Range Destination0[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x51\cell Range Destination0[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x52\cell Range Mask2[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x54\cell Range Destination1[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x55\cell Range Destination115:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x56\cell Range Mask1[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x60\cell RAM base [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x61\cell RAM base [15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x64\cell RAM bound [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x65\cell RAM bound [15:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x68\cell Vector Table Base [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x69\cell Vector Table Base [15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x6c\cell Hit Enables [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x6d\cell Hit Enables [15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x70\cell ROM Bound [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x74\cell ROM Base [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x78\cell Super Nintendo Control\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x79\cell SRAM Protect\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x7c\cell Address Status [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x7d\cell Address Status [15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x80\cell Smart Control [7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x81\cell Smart Control [15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x84\cell Smart Status\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x88\cell VSync Count[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x89\cell VSync Count[15:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x8c\cell Modem Control 1\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x90\cell Modem Transmit Buffer\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x94\cell Modem Receive Buffer\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x98\cell Read Modem Status 2\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0x9c\cell Serial Vertical Count Tag\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xa0\cell Read Modem Status 1\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xa4\cell Guard Count\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xa8\cell Baud Count Divisor[7:0]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xa9\cell Baud Count Divisor[15:8]\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xac\cell Modem Control 2\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xb0\cell Write VSync (testing... do not use)\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xb4\cell LED Data\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 0xb5\cell Enable LEDs\cell }\pard \intbl {\fs20 \row }\pard \intbl {\fs20 \cell \cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0xc0-0xff\cell modem address space\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par Control Register Map\par }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x00\cell Kill Register\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx4240\clshdng0\cellx8560\pard \intbl {\fs20 0x01\cell Control Register\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The address above can be converted into actual addresses based upon the following formula. N decodes to 3 on SEGA, F on SNES.\par \par If "here" or soft here and "fixed internals"\par \tab  then address = 0xNbc001 | register number << 1 ;\par \par if "soft here" and enable internals\par \tab then address is "ROM Top (bit 9 asserted)" | register number << 1 +1\par where ROM top is defined later.\par \par The control registers can be found at one of three locations\par \par if "here" or soft here and "fixed internals"\par \tab then address = 3bNe01 | register number << 1\par }\pard \li720\ri720 {\fs20 \par }{\b\fs18 kiss:  }{\fs18 [Note: this doesn't seem to be correct. Try Nbce01.]\par }{\fs20 \par }\pard {\fs20 \par if soft here and "enable internals\par \tab then address is "ROM Top (bit 9 not asserted)" | register number << 1 +1\par \par if soft here \par \tab if SEGA then address is 0x181 | register number << 1\par \tab if SNES then address is 0x4f00 | register number << 1\par }\pard \li720\ri720 {\fs20 \par }{\b\fs18 kiss:  }{\fs18 SNES Note: There is a bug related to the kill register, and in soft here mode the kill register actually does not appear at 0x4f00. In soft here mode, it appears that the only way to access the kill register is by setting "enable internals" and accessing it through ROM Top (bit 9 not asserted). Also, because the SNES can only read a byte, each vector access causes the soft here counter to increase by 2, not by 1. A good workaround is to decrement the soft here counter by 1 immediately upon entry into your newly vectored routines. (In any case, you should decrement the soft here counter twice before returning from your vectored routines.)\par }{\fs20 \par }\pard {\fs20 \par Access Modes\par As described earlier, Fred has two fundamental modes that it operates in.  In the first, only the card resources are available, and the "here" memory map is correct.  In the second, the cartridge is completely visible with overlay when the chip is "soft here".\par \par When the cartridge is mapped in (not here)\par \par There are two Memory remapping.\par \par The Fred chip allows significant flexibility in its memory map.  The simplest remapping is swapping the ROM and RAM in here mode.  This is accomplished by setting the ROMHi bit in the control register.\par \par The rest of the memory remapping is available in soft here mode.  ROM and RAM can be mapped in at a selectable address, for a selectable length.  This is accomplished by writing the base and bound registers and enabling the bits.\par \par RAM Base[15:0] and RAM Bound[15:0] define the location of Fred SRAM based upon\par \tab RAM access if (RAM Base[15:0]  < address[20:5] < RAMBound[15:0]\par where the address in RAM is defined by address[20:5] - RAM Base[15:0]\par \par ROM Base [7:0] and ROM Bound[7:0] define the location of Fred ROM based upon\par \tab ROM access if (ROM Base [7:0] < address [20:13] < ROM Bound [7:0]\par where the address in ROM is defined by address [20:13] - ROM Base [7:0].  In addition, the ROM is only visible if the "Enable Safe ROM" bit in the control register is asserted.\par \par Finally, the control registers can also be remapped.  When in soft here mode, the registers can appear at "ROM Top", which is  defined by\par \tab Register access if (ROM Bound == address [20:13] )\par As with the ROM, this access must be enabled by asserting a bit in the control register, this time "Enable Internals".\par \par Register description\par }{\b\fs20 Control (7 bits)\par }{\fs20 The control register is the primary place where address space translation is accomplished.\par }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [6]\cell EnSEGAExcept\cell {\fs20 Enable Sega page 2 RAM access\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [5]\cell EnSNESExcept\cell {\fs20 Enable SNES additional exception space\cell }\pard \intbl {\fs20 \row }\pard \intbl [4]\cell EnFixedInternal\cell {\fs20 Turn on registers an normal location\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell EnInternal\cell {\fs20 Turn on registers at top of ROM\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell ROMHi\cell {\fs20 Move ROM to 0x200000 and RAM to 0\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell EnSafeROM\cell {\fs20 Turn on ROM region when "safe here"\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [0]\cell EnTwoRAM\cell {\fs20 Enable second RAM chip on SNES\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par }\pard \li720\ri720 {\b\fs18 kiss:}{\fs18   Changed description of "EnInternal"\par }\pard {\fs20 \par The EnSegaExcept bit turn on RAM access in the region between 0x100 and 0x200 when not here.  This provides additional space for global variables.  This is off by default to avoid stepping on the Sega cartridge verification handshake.\par The EnSNESExcept maps RAM onto the region between 0xff00 and 0xffe0 when in soft here mode, enabling a jump to where RAM is really mapped in.  The RAM address mapped in is 0xff00-0xffe0, or the top of SRAM.\par The EnFixedInternal bit  allows access to the Fred and Modem registers when not here.  They are at the same address ([3 orF]bc000) they would normally appear at in here mode.\par The EnInternal register allows access to the Fred and Modem registers in a reprogrammable manner.  They appear at addr[20:13] == ROMBound[7:0] .\par The ROMHi bit only effect "here" mode.  It swaps ROM high (0x200000) and RAM low (0)\par EnSafeROM allows access to the ROM when not here.  See the discussion of ROMBase and ROMBound.\par EnTwoRAM disables the chipselect for the first RAM chip in the region in odd 32k address.  This allows two 32kx8 RAM chips to be placed and each half of the data bus.  This is used only on the SNES, which does 8 bit access to the cartridge.\par \par }{\b\fs20 Kill (4 Bits)\par }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [3]\cell Force\cell {\fs20 Force soft counter to zero\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [2]\cell Soft\cell {\fs20 Decrement soft counter by one\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell Not used\cell {\fs20 \cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx640\clshdng0\cellx3520\clshdng0\cellx8560\pard \intbl [0]\cell Plain\cell {\fs20 Set "Here" bit to state of plain\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The bits in the kill register control transitions between card modes. There are three basic modes of operation for the card.  The first is "here", which allows access to all card resources and hides the cartridge completely. The second is "normal" which has the cartridge visible, with certain enabled regions mapping to card resources.  Finally, there is soft here, where the cartridge is active, but RAM and potentially ROM and the registers are mapped into the address space.\par The normal and soft here modes are specifically tailored for patching game cartridges.  The mechanism relies on exception vectoring through zero page.  When a certain piece of code in the cartridge is to be patched, an op-code that vectors through the exception page is inserted.  If the card was in normal mode, this causes the card to transition in "soft here" mode, which maps in RAM.  Presumably, the exception vector point to the newly mapped in RAM, allowing the card to take control.  NOTE  On SNES, the transition to soft here always maps in RAM between 0xff00 and 0xffff, allowing a short jump to where one wants RAM to actually reside.\par Of course, things are not quite clean.  Because exceptions can occur at any time, Fred must keep track of how many times the card has gone through the exception vectors.  For example, if the card is just completing a vertical interrupt handling routine, where does it return to, the card or the cartridge?  To solve this, Fred increments a counter each time the exception vectors are read, and decrements the same counter each time the card asserts the soft kill bit. This deals with the additional state of on or off card.\par In addition, because changes to the softHere counter imply changes in address space, the Fred does not immediately implement any changes implied by a write to the kill register.  A magic address (set by the magic address register) must first be hit.  This separates the setting of the transition actions from the change in code flow. See the magic address register for more description.\par \par The bits in the Kill register have the following effect\par Force sets the soft here counter to zero at the next access to the "magic address".\par Soft decrements the soft here counter on the next access to the magic address. NOTE the soft here counter pins to zero and seven, and will not wrap.\par Plain set the here bit to the written state on the next access to the magic address.\par \par }{\b\fs20 Translation Address (23 bits, 3 registers each, 11 instances)\par }{\fs20 The address stored in the register defines a 16 bit word address that should be translated.  The location referenced will cause an access from card RAM (see Vector Table Base later) rather then from cartridge ROM.  The typical use is to map in an illegal or trap instruction, allowing the card to gain control of program flow through the zero page functionality.\par The translation address register only has effect in not here modes.\par On the Sega platform, the two upper most bits of these registers must to be set to ones.  These bits are only used on the SNES platform where they are used to enable 24 bits of addressing.  NOTE the SNES is a byte machine, but patches are still word aligned.\par \par }{\b\fs20 Range Start (23 bits, 3 registers each, 2 instances)\par }{\fs20 These two registers define the beginning of the range translation space.  They allow large areas of memory to be mapped out and replaced with areas from the card.  The comparisons are a little strange in order to reduce the number of gates used. The actual comparison used is (word addresses!!!!)\par \tab (addr[22:12] == rangeStart[22:12] ) && (addr[11:0] >= rangeStart[11:0]) ;\par This is used in conjunction with rangeEnd to define a region.  If the region is less then 11 bits (4 k bytes) in length, every thing will behave as expected.  This mechanism will not work for any larger regions. The resulting region defines the space that will be replace by an same sized region is SRAM or ROM (see the Range Destination Register). NOTE a bug in SEGA 1.0 (and early SNES boards) cause the range registers to function strangely.  Come ask if you care.\par \par }{\b\fs20 Range End (23 bits, 3 registers each, 2 instances)\par }{\fs20 These two registers define the end of the range translation space.  They allow large areas of memory to be mapped out and replaced with areas from the card.  The comparisons are a little strange in order to reduce the number of gates used. The actual comparison used is (word addresses!!!!)\par \tab (addr[22:12] == rangeEnd[22:12] ) && (addr[11:0] <= rangeEnd[11:0]) ;\par (yes, it would be possible to save some bits since the upper ten bits must always be the same as the equivalent rangeStart... sorry, I was in a hurry).\par \par }{\b\fs20 Magic Address (23 bits, 3 registers )\par }{\fs20 This register defines a magic address that causes address space translations to occur.  Changes to the kill register that cause transitions between here and not here modes do not take effect until this address specified in this location is hit.  This allows fairly direct code, such as\par \tab set the kill register\par \tab push the address I want to go to\par \tab rts to the cartridge\tab \tab <<<<< magic address points here\par The rts to the cartridge is important since the address space translation takes place immediately.  Multi-word instructions can get VERY confused.  See the kill register discussion for a more complete discussion.\par \par }{\b\fs20 Range Destination (16 bits, 2 registers, 2 instances)\par }{\fs20 The range destination defines where the two translation ranges defined by the range start/end pairs end up.  The upper most bit (15) indicates ROM if set and RAM if not set.  The rest of the bits define the address in RAM to map the translated range to.  The actual algorithm used is\par \tab \{trRange[14:8],(addr[11:4] & ~trMask) | (trRange[7:0] & trMask),addr[3:0]\}\par Got that?  okay, in English, the output address (to either RAM or ROM) consists of the value bits 14:8 of the range register shifted to bits 18:12 of the output address.  The next eight bits optionally come from either the address or the range register.  This allows an varying size region to be mapped in, without any major math.  If a bit in the mask register (described shortly) is set it indicates that the corresponding bit in the address to RAM/ROM should come from the range register.  If the bit is clear, the bit comes from the accessed address.  Finally, the low order 4 bits (32 bytes) always come from the accessed address.\par In use, the mask should consist of some number of ones followed by some number of zeros.  To map in 256 bytes of ROM with a 1k byte offset into the ROM space, set the Range Destination register to 0x8020 and the mask register to 0xf8.  The equations does\par \tab 14:8<<4 = 0x00<<4 = 0\par \tab 7:0&mask<<4 = 0x20&0xf8<<4 = 0x200 (remember, we be in word offsets)\par \tab addr[11:4] & ~mask = addr[6:4]\par \tab addr[3:0]\par which, putting it together yields 0x2006 | addr[6:0].  Which gives us a 256 byte chunk (address are in words) starting at 1k.  Note the since there is no subtraction the access to this region will wrap.  Thus, whatever alignment the source region has will be the same alignment seen within the destination region.\par \par }{\b\fs20 Range Mask (8 bits, 2 instances)\par }{\fs20 A mask that defines which bits are used from the range register and which are used from the translated address. See the range destination register for a full description.\par \par }{\b\fs20 RAM Base (16 bits, 2 registers)\par }{\fs20 The RAM base register defines where in cartridge space RAM should be mapped when in soft here mode.  The equation used is \par \tab \{RAMBaseOffset[13:0],addr[4:0]\} where\par \tab RAMBaseOffset = addr[20:5] - RAMBase\par The RAM base must always be on a 64 byte boundary. Note that a subtraction is done to normalize the ram base, so the first address with the RAM safe region will access address 0 in the RAM. NOTE FOR SNES, check the SNES Control register docs below.\par \par }{\b\fs20 RAM Bound (16 bits, 2 registers)\par }{\fs20 The ram bound register defines the end of the safe RAM region when in soft here mode. It is constrained to 64 byte boundary. NOTE FOR SNES, check the SNES Control register docs below.\par \par }{\b\fs20 ROM Base (8 bits, 1 registers)\par }{\fs20 The ROM base register defines where in cartridge space ROM should be mapped when in soft here mode and the EnSafeROM bit is asserted.  The equation used is \par }\tab \{ROMBaseOffset[5:0],addr[12:0]\} where\par \tab ROMBaseOffset = addr[20:13] - safeROMBase \par {\fs20 The ROM base must always be on a 8k byte boundary. Note that a subtraction is done to normalize the ram base, so the first address with the ROM safe region will access address 0 in the ROM. NOTE FOR SNES, check the SNES Control register docs below.\par \par }{\b\fs20 ROM Bound (8 bits, 1 registers)\par }{\fs20 The ram bound register defines the end of the safe R0M region when in soft here mode. It is also constrained to an 8k boundary. The ROM bound register also defines the beginning of the registers if the EnInternal bit is asserted.  NOTE FOR SNES, check the SNES Control register docs below.\par \par }{\b\fs20 Vector Table Base (16 bits)\par }{\fs20 The vector table base register defines the location in RAM that words are fetched from for the individual word patches.  The actual equation used is\par \tab }vectorTableBase[14:0],vectorNumber[3:0]\par {\fs20 where the vector number is derived from the patch number (patch 0 is vectorNumber0 etc). Remember, these are 16 bit address, so there is an implied zero at the base to assure even addressing.\par \par }{\b\fs20 Hit Enables (16 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [15]\cell vector enable\cell {\fs20 are vectors overlayed by the card\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [14]\cell not used\cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [13]\cell not used\cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [12]\cell range 1 enable\cell {\fs20 enable the upper range overlay\cell }\pard \intbl {\fs20 \row }\pard \intbl [11]\cell range 0 enable\cell {\fs20 enable the lower range overlay\cell }\pard \intbl {\fs20 \row }\pard \intbl [10]\cell patch 10 enable\cell {\fs20 enable patch 10 for game overlay\cell }\pard \intbl {\fs20 \row }\pard \intbl [9]\cell patch 9 enable\cell {\fs20 enable patch 10 for game overlay\cell }\pard \intbl {\fs20 \row }\pard \intbl [.]\cell \cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [.]\cell {\fs20 more patch enables\cell \cell }\pard \intbl {\fs20 \row }\pard \intbl [.]\cell \cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell patch 2 enable\cell {\fs20 enable patch 2 for game overlay\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell patch 1 enable\cell {\fs20 enable patch 1 for game overlay\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell patch 0 enable\cell {\fs20 enable patch 0 for game overlay\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The hit enable register controls patching of cartridges.  There are really four different classes of enables in this register.  The Vector Enable bit turns on overlay from 0-0x100 on SEGA, 0xffe0-0xffff on SNES. It maps the first equivalent words of RAM onto the first patched words of the cartridge, taking over all exception handling. Since vector accesses control transitions to soft here (and thus to any other mode) this bit should always be asserted when running a game patch.  If not, there is no way to get back to soft here mode, as no card resources are visible.\par The two range enable bits enable range mapping, patch a range of the cartridge with a range from RAM or ROM.\par The 11 patch enables turn on individual word patches.  Each patch replaces a single word in the cartridge with a single word from RAM.\par }{\b\fs20 \par SNES Control (4 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [3:2]\cell ROMHiBits\cell {\fs20 upper 2 bits of safe ROM address\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [14]\cell RAMHiBits\cell {\fs20 upper 2 bits of safe RAM address\cell }\pard \intbl {\fs20 \row }\pard \par {\fs20 The SNES contol register manages the placement of safe RAM and ROM during soft Here mode.\par The ROMHiBits must be equal to upper bits of the ROM address for a safe ROM hit to occur.\par The RAMHiBits must be equal to upper bits of the RAM address for a safe RAM hit to occur.\par \par }{\b\fs20 SRAM Protect (8 bits)\par }{\fs20 \par The SRAM protect register disables writes to regions of the SRAM.  The register defaults to all zeros, which is also NO PROTECTION for backwards compatibility.\par Otherwise the logic is\par \tab Protected if addr[16:9] >= ~SRAMProtect[7:0]\par or, in english, the SRAM protect register has resolution of 1k bytes, and is set with the bitwise inverse of the lowest writable address.  Thus, setting the SRAMProtect register to FF, protects all except the lowest 1 K of SRAM.  Note that the span of the register is 256k bytes, and aliases will occur on that boundary within the SRAM regions.\par \par }{\b\fs20 Address Status (16 bits, 2 registers) (read register)\par }{\fs20 \par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [15]\cell here\cell {\fs20 current in here mode or not\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [14:11]\cell not used\cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [10:8]\cell soft here count\cell {\fs20 current value of the soft here counter\cell }\pard \intbl {\fs20 \row }\pard \intbl [7]\cell not used\cell {\fs20 \cell }\pard \intbl {\fs20 \row }\pard \intbl [6]\cell EnSEGAExcept\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [5]\cell EnSNESExcept\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [4]\cell EnFixedInternal\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell EnInternal\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell ROMHi\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell EnSafeROM\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell EnTwoRAM\cell {\fs20 current status of this bit\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par }{\b\fs20 Smart Control (12 bits ) (read and write register)\par }{\fs20 The smart control register controls the smart card interface.  The smart card interface support both ISO asynchronous and synchronous serial protocols.\par \par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [11:9]\cell clockDiv\cell {\fs20 if uart mode, defines clock to card\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [8]\cell outputVpp\cell {\fs20 if asserted, drives VPP to card\cell }\pard \intbl {\fs20 \row }\pard \intbl [7]\cell SmartUart\cell {\fs20 enable uart communication with card\cell }\pard \intbl {\fs20 \row }\pard \intbl [6]\cell outputData2\cell {\fs20 auxiliary data to output\cell }\pard \intbl {\fs20 \row }\pard \intbl [5]\cell enOutputData2\cell {\fs20 if 1, data2 is an output\cell }\pard \intbl {\fs20 \row }\pard \intbl [4]\cell outputVcc\cell {\fs20 power to the card\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell outputReset\cell {\fs20 reset to the card\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell outputData\cell {\fs20 data to the card\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell enOutputData\cell {\fs20 if 1 data is an output\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell outputClk\cell {\fs20 if not uart mode, this bit is output\cell }\pard \intbl {\fs20 \row }\pard \qc {\fs20 \par \par }{\fs20 {\pict\macpict\picw258\pich222 02c4ffffffff00dd01011101a0008201000affffffff00dd0101090000000000000000310002000200da00fe070004000409ffffffffffffffff300000000000dc0100a0008c2200360000480022006c000048002200a2000048002312e52300ca2200360048121b22006c004812002200000063123f220051005a1bee220087005a1b122200d8006312c1a0008da0008c22003600fcb80022006c00fcb8002200a200fcb80023eee52300ca22003600b4ee1b22006c00b4ee002200000099ee3f22005100a2e5ee22008700a2e5122200d80099eec1a0008da10096000c010000000200000000000000a1009a0008fffb00000021000001000a001100150021005b2c000b0002084e657720596f726b0300020d000c2e0004000001002b161d08736d617274564343a00097a10096000c010000000200000000000000a1009a0008fffb0000001f000001000a007d000a008d004b280089000b08736d617274436c6ba00097a10096000c010000000200000000000000a1009a0008fffc00000027000001000a00bc001400cc00652b0a3f0a736d6172744461746132a00097a10096000c010000000200000000000000a1009a0008fffc00000022000001000a00bc00a900cc00f1299508736d617274565050a00097a10096000c010000000200000000000000a1009a0008fffb00000023000001000a007d00b1008d00fa28008900b209736d61727444617461a00097a10096000c010000000200000000000000a1009a0008fffc00000023000001000a005000b2006000fa28005c00b308736d617274565050a00097a10096000c010000000200000000000000a1009a0008fffb0000001a000001000a001100b1002100e828001d00b20647726f756e64a00097a10096000c010000000200000000000000a1009a0008fffc00000026000001000a0050000a0060005928005c000b0a736d6172745265736574a00097a00083ff}}{\fs20 \par }\pard {\fs20 \par The smart card interface supports both uart based smart cards and synchronous clocked devices.  In uart based devices, data and clock are used to pass data to and from the card.  Note that some parameters for this mode must be set in the modem subsection.  Also note Fred has 1 serial port which can be used either to communicate with the smart card or to the modem.  Asserting the smart uart bit immediately grabs control of the serial port, so care should be used.\par The clockDiv values define the smart card interface clock when in uart mode.  The base clock is 24 MHz, which can be divided by 2 (clockDiv = 0), 4 (clockDiv = 1), 6 (clockDiv = 2) or 8 (clockDiv = 3).\par The outputVpp pin nominally is used to enable programming of the card.  It does nothing special, just asserts its value to the smartVPP pin.  It is also connected to one of the undefined pins to enable greater compatibility with non-standard cards.\par SmartData is a bi-directional pin for I/O with the card.  If the EnDataOut signal is asserted it is driven, else it is tri-stated.\par SmartData2 is identical to smart data, it just connects to a different pin.\par OutputClk is driven on the smartClk pin if the smartUart bit is not asserted.\par SmartVCC control power to the smart card. It also controls the tri-states on all of the output only signals, allowing safe hot insertion of the smart card.\par \par }{\b\fs20 Smart Status (8 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [7]\cell outputVpp\cell {\fs20 current state of this bit\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [6]\cell outputVcc\cell {\fs20 current state of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [5]\cell outputReset\cell {\fs20 current state of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [4]\cell outputData\cell {\fs20 current state of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell smartClk\cell {\fs20 current state of this bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell smartData2In\cell {\fs20 the current state of the pin\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell smartDataIn\cell {\fs20 the current state of the pin\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell smartDetect\cell {\fs20 if 1 a card is in\cell }\pard \intbl {\fs20 \row }\pard {\fs20 \par The Fred serial ports is optimized to communicate with the Rockwell 2424DP modem chip.  It is a full UART implementation with extensions to support synchronous data and time stamping.\par The serial port has 4 characters of buffer both on the input and output directions.  This is sufficient to \par \par }{\b\fs20 Serial Control 1 (8 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [7]\cell break\cell {\fs20 sends a break until cleared\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [6]\cell oddParity\cell {\fs20 if parity is enabled, make it odd\cell }\pard \intbl {\fs20 \row }\pard \intbl [5]\cell enParity\cell {\fs20 enable parity bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [4]\cell oneStop\cell {\fs20 if stop bits, send just one instead of two\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell enStop\cell {\fs20 enable stop bit\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell bit_8\cell {\fs20 send 8 bits instead of seven\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell reset{\fs20 Serial \cell clears serial status if asserted\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell en{\fs20 Serial \cell turns the serial port on\cell }\pard \intbl {\fs20 \row }\pard {\fs20 The serial control 1 register is the primary control register for the serial port.  The enSerial bit turns the modem on or off.  No other bits have any effect if this bit is asserted.  \par The resetSerial bet clears all state EXCEPT the fifos.  It should be asserted any time the clock divisor is changed, and whenever it is not clear what state the port may be in.\par The remaining bits in the register are standard UART control bits.  The break bits forces the transmit line low until the bit is deasserted.  This creates a unique pattern (framing error with 0 data) that is often used as an attention signal to the remote device.\par The enParity and oddParity bits control define the parity protocol used on the line.  If the enable bit is asserted, parity will be generated and checked with polarity as defined by the oddParity bit.  If the enable bit is low, not parity is generated or checked.\par The enStop and oneStop bit function similarly to the parity control bits.  If the enable bit is asserted, stop bits will be generated.  If the oneStop bit is asserted only a single stop bit will be asserted, otherwise 2 will be generated.  If the enable bit is 0, no stop bits will be generated.  Note that this mode will only work for synchronous communication since stop bits are required to define end of words in asynchronous mode.\par Bit_8 controls the number of bits per word transmitted.  If asserted, 8 bits are sent, if clear only seven bits are sent.\par \par }{\b\fs20 Serial Control 2 (4 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [3]\cell syncMode\cell {\fs20 Enable synchronous mode\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [2]\cell enSmartcard\cell {\fs20 Route signals to smart card not modem\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell enSmartTxRetry\cell {\fs20 ISO compliant retries on transmit\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell enSmartRxRetry{\fs20  \cell ISO compliant retries on receive\cell }\pard \intbl {\fs20 \row }\pard {\fs20 The serial control 2 register contains all the auxiliary control bits for the serial port.\par The syncMode bit places the serial port in synchronous communication mode. The Rockwell part we are using generates a transmit and receive clock for the serial interface. If the syncMode bit is asserted, the serial port samples asserts data synchronous to this clock.  This in theory enable a fully synchronous interface protocol, eliminating stop bits. If the syncMode bit is not asserted (0) the serial port behaves as a normal UART.\par The smartcard and modem both need a UART type interface. To save money, only a single serial port exists in Fred, with a multiplexor at the front end.  This implies that only one of the two devices can be active at a time.  When the enSmartCard bit is asserted, Fred samples data from the smartcard.  Note that the Rockwell should be set to not care about the state of its TXD input pin, since it is not disabled during interaction with the smartcard.\par The enSmartTx and Rx Retry bits enable the ISO specified retry protocols.  If the transmit bit is asserted, Fred will retransmit words in response to a retry request from the smartCard.  If the RxRetry bit is asserted, Fred will generate retry requests in the event of parity or framing errors, and will discard the errored word. At most 3 retries will be attempted per word, with the number of retries attempted for the last word reported in the smartXxNumRetry bits described later.\par \par }{\b\fs20 Read Serial Status 1 (8 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [7:6]\cell smartTxNumRetry\cell {\fs20 number of retries attempted\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [5:4]\cell smartRxNumRetry\cell {\fs20 number of retries attempted\cell }\pard \intbl {\fs20 \row }\pard \intbl [3]\cell overRun\cell {\fs20 receive overrun\cell }\pard \intbl {\fs20 \row }\pard \intbl [2]\cell rxBreak\cell {\fs20 receive break\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell txEmpty\cell {\fs20 transmit buffer is empty\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell txFull\cell {\fs20 transmit buffer is full\cell }\pard \intbl {\fs20 \row }\pard {\fs20 The txFull bit indicates that the transmitt fifo is full.  If this bit is asserted, no writes to the transmitt buffer are allowed.\par The txEmpty bit indicates that the four fifo entries are clear and available for writing.  If asserted, software can write four bytes without overflowing the fifo (though the txFull bit should be checked as the fifo is a flow through device that is momentarily "full" after each byte is written).\par The rxBreak register indicates that a break has been received. It is stored only for the first word of the break, and is cleared when the Status 1 register is read.\par The overRun bit indicates that a receive overRun has occurred.  This indicates that a byte was fully received in the shift register, the fifo was full AND the beginning of a new word was received.  Fred can store 5 bytes in the receiver, four in the Fifo and one in the shift register itself. The beginning of the sixth byte trashes the byte in the serial register. This bit is cleared each time it is read.  Note that the overRun bit is cleared each time it is read.  To reliably track overrun errors, every time the register is read this bit should be stored.\par The smartTx and smartRxNumRetry bits indicate the number of retries attempted for ISO compliant smart cards.  Like overRun and rxBreak, these bits are cleared each time they are read. These bits are also cleared by a successful transaction, so they will only be non-zero if a byte is actively being retried, or has failed because more than 3 retries have occurred.\par \par }{\b\fs20 Read Serial Status 2 (5 bits)\par }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [4:3]\cell serialFrameCnt\cell {\fs20 latch frame byte was received on\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [2]\cell parityError\cell {\fs20 parity error of byte in fifo\cell }\pard \intbl {\fs20 \row }\pard \intbl [1]\cell frameError\cell {\fs20 frame error of byte in fifo\cell }\pard \intbl {\fs20 \row }\trowd \trgaph80 \clshdng0\cellx1360\clshdng0\cellx4096\clshdng0\cellx8560\pard \intbl [0]\cell rxReady\cell {\fs20 is there valid data in the fifo\cell }\pard \intbl {\fs20 \row }\pard {\fs20 The serial status 2 register constrains the important receive data associated with each byte.\par The rxReady bit indicates there is valid data in the fifo to be read.\par The frameError, parityError, and serialFrameCnt bit all have fifos associated with them, matching the fifo used for received data. These bits are "popped" along with the data when the rxBuffer is read.\par The frameError bit indicates that a frame error occurred while receiving the associated byte.  A valid "frame" of data consists of a start bit, data bits, an optional parity bit and a frame bit.  The frame bit is simply a 1 used to guarantee that all data has at least one zero (the start bit) and one one (the stop bit).  A frame error occurs when a frame bit was expected but a 0 was received.\par A parity error occurs when the calculated value of parity does not match the received value.  This is pretty good at detecting single bit errors, and very bad at detecting anything else.\par The serialFrameCnt is part of the Sync-o-tron (patent pending) implementation.  It is simply a two bit sequence tag indicating which frame a byte was received on.  It passes through an identical fifo to the data.\par The upper bits of this register are used to provide test visibility and have no useful function (3 bits of the baud counter). \par \par }{\b\fs20 Serial Transmit Buffer (8 bits)\par }{\fs20 The serial transmit buffer is where you write bytes that you want to send.  Check the txFull bit before writing this register to avoid stepping on data if the fifo is full.\par \par }{\b\fs20 Serial Receive Buffer (8 bits)\par }{\fs20 The serial receive buffer is where incoming data arrives.  The data is fifo, and will be cleared immediately upon reading.  In addition, the top entry on the serial vertical count fifo as well as the parityError, frameError and serialFrameCnt bits will all be "popped" when the serial buffer is read.  The pattern for access of the receive buffer should be read the serial status register to see if there is valid data, if so store the state bits in that register.  Read the serial vertical count register, then read the serial receive buffer.\par \par }{\b\fs20 VSync Count (16 bits)\par }{\fs20 The VSync Count register contains 16 bits of count starting at the beginning of the current field.  This count is driven off a 12 MHz clock, asynchronous to the CPU.  Unfortunately, due to brain damage to the designer, there is not synchronization circuitry.  To get valid data, read the registers twice and make sure you get the same number.  Of course, since the counter is changing faster then the CPU, some intelligence must be used.  Reading the counter multiple times until two values within the possible variance can yield all the bits accurately.\par \par }{\b\fs20 Serial Vertical Count (8 bits)\par }{\fs20 The serial vertical count register is simply the VSync Count register latched at the time the serial received byte is pushed onto the fifo.  It is another aspect of the Sync-o-tron circuit, and tags serial data with the time it is received.\par \par }{\b\fs20 Guard Count (8 bits)\par }{\fs20 The guard count defines the number of bit times the line must be idle before the next byte can be sent.  This is specifically to be compliant with the smart card ISO specification.  It should normally be zero for all other applications.\par \par }{\b\fs20 Baud Count Divisor (16 bits)\par }{\fs20 The baud count divisor defines the frequency of the baud clock for the serial port when running in asynchronous mode.  It has no effect on synchronous mode communication.  A value of zero corresponds to 12 MHz operation.\par \par }{\b\fs20 Enable LEDs (8 bits)\par }{\fs20 The LEDs are actually driven by bi-directional drivers.  For each bit, asserting a 1 for Enable LEDs makes that driver an output.  Note bit 7 should always be written to a 1, and this should be done at startup of the OS every time.  The smart card detect pin is multiplexed for test purposes, and if EnableLED[7] is low, it outputs test information.\par \par }{\b\fs20 LED Data (7 bits)\par }{\fs20 The low seven bits of this register control the LED data.  The actual data presented on the pins is the inverse of the values in the register.  This has the effect of turning the LEDs on when a one is written to the register. Bit 0 is the uppermost LED on the board.\par \par On the Super Nintendo, bit 6 is tied to the reset line.  When asserted low it will reset the entire machine, including Fred.  Bits 1, 3, and 5  are the LEDs themselves.  Bit 0 is connected to the potentially present Dallas permanent ID chip.  It should be left tri-stated by all other applications.\par \par }\par }